import { Callout } from "nextra/components"

# REST API

## Overview

ROQ use JSON:API specification to minimizes the number of requests and the amount of data transmitted between clients and servers. Its design allows for fetching, creating, and updating multiple resources in a single request, making operations more efficient.

## What is JSON:API?

JSON:API is a specification for how a client should request that resources be fetched or modified, and how a server should respond to those requests. It provides guidelines for structuring requests, responses, and the HTTP methods and status codes to employ. It embraces RESTful conventions, however, it also defines conventions for building and modifying resources via HTTP.

**Features**

- Standardizes how APIs are designed and how requests and responses are handled, promoting interoperability.
- Specifies the use of JSON in request and response bodies, with conventions for how resources and their relationships should be represented.
- Supports fetching and modifying resources, and provides mechanisms for transactions and error handling.
- Embraces RESTful principles, but also includes conventions for actions not covered by REST.

For more information, visit the [JSON API Official Website](https://jsonapi.org/).

## Interacting with the REST API

You need a token to access the REST API in the ROQ BaaS. 

Let's take a look at this code:

```tsx
const count = await roqClient.book.count({ orderBy: { created_at: 'desc' }})
```

The code tell us to query the book count data with descending order. This code will translated to the REST API call:

```shell
https://book-story-v1-ca2b-baas.vercel.app/api/model/book/count?q=%7B%22orderBy%22%3A%7B%22created_at%22%3A%22desc%22%7D%7D
```

The endpoint `/api/model/book/count` indicates an action (`count`) on a model (`book`). The `q` query parameter appears is a JSON object, URL-encoded, which specifies how the counting should be performed. In this case, it's instructing the server to order the books by their `created_at` timestamp in descending order (`desc`) before performing the count.

We can use tools such as [Postman](https://www.postman.com/) to call the REST-API's book count endpoint with the necessary request authorization using **Bearer Token**. 

![postman](/screenshots/postman-roq-baas-query.png)

## Token

Whenever a user successfully logs in, a user token is generated. This token is used to identify the user for subsequent requests made to the ROQ BaaS.

### Get the user token

To access the ROQ BaaS REST API, you need an authorization token known as `roq-session-token`. In a Next.js application, you can programmatically retrieve the user token for authorization. This token is stored in a browser cookie with the `HttpOnly` flag, which means it cannot be directly accessed using JavaScript on the client side.

There a few ways to get the user token. You can get it manually for fast testing and development or you can get the token programmatically.

#### Programmatically

In the Next.js application, we can use the `getServerSideProps()` method to get the token.

```tsx
export async function getServerSideProps(context) {
	const { req } = context;
	const cookies = req.headers.cookie?.split(';');
	const tokenCookie = cookies?.find(cookie => cookie.trim().startsWith('roq-session-token='));
	const token = tokenCookie?.split('=')[1];
  
	return {
	  props: { token }
	};
}
```

The `getServerSideProps()` function allows you to fetch data server-side per request and use it as props in components. This is the full example code on how to get the `roq-session-token` and use the token to query book count data.


```tsx filename="book.tsx" {21, 53-63}
import { useRoqClient } from 'lib/roq'
import { requireNextAuth, useSession } from '@roq/nextjs'
import { useEffect, useState} from 'react'

export default function Book({token}) {
	return <AuthenticatedSection token={token}/>
}

const AuthenticatedSection = ({ token }) => {
	const { session, status } = useSession()
	const [bookCount, setBookCount] = useState(0)
	const roqClient = useRoqClient()

	useEffect(() => {
		//fetch book count
		const fetchBookCount = async () => {
			const count = await roqClient.book.count({
				orderBy: { created_at: 'desc' }
			},{
				headers: {
					Authorization: `Bearer ${token}`
				}
			})
			setBookCount(count)
		}
		fetchBookCount()

	}, [])

	function logoutHandler() {
		roqClient.signOut()
	}

	return (
		<div className='m-5'>
			{session ? (<>
				<p className='my-10'>Logged in as: <strong>{session?.user.email}</strong></p>
				<p>Book Count: {bookCount}</p>
				<br />
				<button
					onClick={logoutHandler}
					className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
				>
					Logout
				</button>
               
			   <br/>
			</>) : 'Not logged in'}
		</div>
	)
}

export async function getServerSideProps(context) {
	const { req } = context;
	const cookies = req.headers.cookie?.split(';');
	const tokenCookie = cookies?.find(cookie => cookie.trim().startsWith('roq-session-token='));
	const token = tokenCookie?.split('=')[1];
  
	return {
	  props: { token }
	};
}
```

#### Manually

The token can also be obtained by copying it directly from the browser cookie and pasting it into the authorization header.

![roq session token browser](/screenshots/roq-session-token.png)